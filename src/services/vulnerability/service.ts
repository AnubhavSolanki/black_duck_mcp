import { blackDuckClient } from "../../client/blackduck-client.js";
import {
  RemediationStatus,
  VulnerabilitySeverity,
} from "../../client/types.js";
import { UnknownOriginError } from "../../utils/errors.js";
import {
  calculateDueDate,
  extractOriginForVulnerability,
  isDateValid,
} from "./service.utils.js";

import {
  getUpgradeGuidance,
  UpgradeGuidance,
} from "./upgrade-guidance.service.js";
import { buildNotFixableGuidance } from "./upgrade-guidance.service.utils.js";

export type Vulnerability = {
  id: string;
  name: string;
  score: number;
  severity: VulnerabilitySeverity;
  publishedDate: string;
  dueDate: string;
  remediationStatus: RemediationStatus;
  remediationComment: string;
  description: string;
  upgradeGuidance: UpgradeGuidance;
};

export async function getVulnerabilities(
  projectId: string,
  projectVersionId: string,
  severity?: VulnerabilitySeverity,
): Promise<any> {
  let filter = "";
  if (severity) {
    filter = `vulnerabilityWithRemediation.severity:${severity}`;
  }

  const queryParams: any = { limit: 100, offset: 0 };
  if (filter) {
    queryParams.filter = filter;
  }

  const response = await blackDuckClient.getVulnerableComponents(
    projectId,
    projectVersionId,
    queryParams,
  );

  const vulnerabilities: Vulnerability[] = [];
  for (const item of response.items) {
    const vuln = item.vulnerabilityWithRemediation;
    if (!vuln || !item?._meta?.href) {
      console.warn(
        `Vulnerable component ${item.componentName} does not have vulnerability details, skipping.`,
      );
      continue;
    }

    const componentOriginId = extractOriginForVulnerability(item._meta.href);
    if (!componentOriginId) {
      console.warn(
        `Unable to extract origin for vulnerability ${vuln.vulnerabilityName}, skipping upgrade guidance.`,
      );
      continue;
    }

    const upgradeGuidance = await getUpgradeGuidance(
      projectId,
      projectVersionId,
      componentOriginId,
    ).catch((error) => {
      if (error instanceof UnknownOriginError) {
        console.log(
          "\x1b[33m Unknown origin for vulnerability " +
            error.vulnerabilityName +
            " \x1b[0m",
        );

        return buildNotFixableGuidance(error.vulnerabilityName);
      } else {
        console.error(
          `Error getting upgrade guidance for vulnerability ${vuln.vulnerabilityName}: ${error.message}`,
        );
        return undefined;
      }
    });

    if (!upgradeGuidance) {
      continue;
    }

    vulnerabilities.push({
      id: vuln.vulnerabilityName,
      name: item.componentName,
      dueDate: isDateValid(vuln.vulnerabilityPublishedDate)
        ? calculateDueDate(
            vuln.vulnerabilityPublishedDate as string,
            vuln.severity as VulnerabilitySeverity,
          )
        : "Unknown",
      score: vuln.baseScore || 0,
      publishedDate: vuln.vulnerabilityPublishedDate || "",
      remediationComment: vuln.remediationComment || "",
      remediationStatus:
        vuln.remediationStatus || ("UNKNOWN" as RemediationStatus),
      description: vuln.description || "",
      severity: vuln.severity as VulnerabilitySeverity,
      upgradeGuidance: upgradeGuidance as UpgradeGuidance,
    });
  }

  return vulnerabilities;
}
