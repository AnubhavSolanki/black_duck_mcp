import { UnknownOriginError } from "../../utils/error.js";
import { UpgradeGuidance } from "./upgrade-guidance.service.js";

export function extractComponentIdsFromPath(
  pathItem: any,
  dependencyType: "DIRECT" | "TRANSITIVE",
): {
  componentId: string;
  componentVersionId: string;
  originId?: string;
} | null {
  if (!pathItem.path || pathItem.path.length <= 1) {
    return null;
  }

  const pathNode = pathItem.path[pathItem.path.length - 2]; // Second to last node
  const links = pathNode._meta?.links || [];

  // Find the appropriate upgrade guidance link
  const guidanceLink = links.find((link: any) =>
    ["upgrade-guidance", "transitive-upgrade-guidance"].includes(link.rel),
  );

  if (!guidanceLink?.href) {
    return null;
  }

  const result = parseComponentIdsFromHref(guidanceLink.href, dependencyType);
  if (!result?.originId) {
    throw new UnknownOriginError(pathNode.name);
  }
  return result;
}

function parseComponentIdsFromHref(
  href: string,
  dependencyType: "DIRECT" | "TRANSITIVE",
): {
  componentId: string;
  componentVersionId: string;
  originId?: string;
} | null {
  const hrefParts = href.split("/");
  const componentsIndex = hrefParts.indexOf("components");
  const versionsIndex = hrefParts.indexOf("versions");
  const originsIndex = hrefParts.indexOf("origins");

  if (componentsIndex === -1 || versionsIndex === -1) {
    return null;
  }

  const result = {
    componentId: hrefParts[componentsIndex + 1],
    componentVersionId: hrefParts[versionsIndex + 1],
    originId: undefined as string | undefined,
  };

  if (originsIndex !== -1 && dependencyType === "TRANSITIVE") {
    result.originId = hrefParts[originsIndex + 1];
  }

  return result;
}

export function buildGuidance(guidance: any): UpgradeGuidance {
  const componentName = guidance.componentName || "Unknown Component";
  const currentVersion = guidance.versionName || "Unknown Version";

  return {
    shortTerm: {
      upgradeFrom: `${componentName} ${currentVersion}`,
      upgradeTo: guidance.shortTerm
        ? `${componentName} ${guidance.shortTerm.versionName}`
        : "No short-term fix available",
    },
    longTerm: {
      upgradeFrom: `${componentName} ${currentVersion}`,
      upgradeTo: guidance.longTerm
        ? `${componentName} ${guidance.longTerm.versionName}`
        : "No long-term fix available",
    },
  };
}

export function buildNotFixableGuidance(
  componentName: string,
): UpgradeGuidance {
  return {
    shortTerm: {
      upgradeFrom: componentName,
      upgradeTo: "No short-term fix available",
    },
    longTerm: {
      upgradeFrom: componentName,
      upgradeTo: "No long-term fix available",
    },
  };
}
